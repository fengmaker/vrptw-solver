这是一个非常棒的思维转变。从“写代码实现功能”到“设计架构管理复杂性”，是算法工程师进阶的关键。

为了帮你建立这种**“模块化思维”**，我将带你进行一次**全链路漫游**。我们将通过两个视角来看待这个项目：

1. **运行时视角（Runtime View）**：代码是怎么跑起来的？（数据流向）
2. **开发视角（Dev View）**：如果要修改需求，牵一发会动谁？（依赖关系）

---

### 第一部分：运行时视角（数据是怎么流动的？）

想象这是一家**物流调度公司**。我们来看看各个部门（文件）是如何协作的。

#### 1. 启动阶段 (`main.py` -> `instance.py`)

* **动作**：你在 `main.py` 里按下了启动键。
* **流程**：
1. `main.py` 呼叫 **档案室 (`instance.py`)**。
2. `instance.py` 读取硬盘上的 `C101.txt`，根据 **数据标准 (`models.py`)** 将文本转化为一个个 `Customer` 对象。
3. **关键点**：此时数据被“冻结”。从此往后，所有模块（Master, Pricing）要查距离、查需求，**只能**问 `instance`，绝不允许自己私下去读文件或改数据。



#### 2. 初始化阶段 (`solver.py` -> `master.py` & `pricing.py`)

* **动作**：`main.py` 创建了 **项目经理 (`solver.py`)**，并将 `instance` 交给他。
* **流程**：
1. 项目经理聘请了 **总经理 (`master.py`)** 和 **探路专家 (`pricing.py`)**。
2. 经理把 `instance` 复印了两份，分别发给总经理和专家，说：“这是地图和客户需求，你们都拿着。”



#### 3. 循环阶段（列生成核心 loop）

这是最精彩的部分，就像打乒乓球：

* **Step A: 总经理决策 (`master.py`)**
* 总经理看一眼当前手里的方案（一开始只有昂贵的虚拟路径）。
* 他运行 Gurobi（解 LP），得出一个结论：“现在的方案太贵了，主要是 **客户 5** 和 **客户 10** 很难搞，服务他们成本很高。”
* **产出**：**对偶值 (Duals)**。你可以把它理解为“悬赏金”。（例如：谁能搞定客户 5，奖励 100 元！）


* **Step B: 传递信息 (`solver.py`)**
* 项目经理从总经理手里拿过“悬赏金列表 (`duals`)”，转手交给探路专家。


* **Step C: 专家寻路 (`pricing.py`)**
* 探路专家拿着地图 (`instance`) 和悬赏金 (`duals`) 开始在图上跑（标签算法）。
* 他的目标不是“距离最短”，而是“利润最高”（Reduced Cost < 0）。也就是：**跑的路尽量短（油费少），顺路捡的赏金尽量多**。
* **产出**：**新路径 (`Routes`)**。


* **Step D: 汇报与迭代**
* 项目经理把新路径交给总经理：“老板，这是专家新发现的省钱路线。”
* 总经理把新路线加入 Gurobi 模型，重新计算... 回到 Step A。



---

### 第二部分：开发视角（如果我要改代码，会发生什么？）

这是你最关心的部分。我们通过三个**真实场景**来训练你的“依赖分析”能力。

#### 场景一：我想给车辆增加一个“最大行驶距离”限制

假设现在的车无限油，现在限制每辆车最多跑 200km。

* **思考路径：**
1. **这是谁的责任？** 限制一辆车能不能跑某条路，这是在生成路径时决定的。所以是 **子问题 (`pricing.py`)** 的事。
2. **需要改数据吗？** 不需要，距离数据已经有了。
3. **主问题关心吗？** 不关心。主问题只管选路径，不管路径怎么跑出来的。只要你给我的路径是合法的，我就用。


* **修改影响范围：**
* `pricing.py`:
* `Label` 类：可能需要增加一个属性 `distance`（如果 cost 不等于 distance 的话）。
* `extend` 函数：在扩展时累加 distance。
* `extend` 函数：增加检查 `if new_dist > max_dist: return None`。
* `is_dominated` 函数：增加对 distance 的支配比较。


* **其他文件：** 0 修改。



#### 场景二：我想增加一个新的客户属性，比如“客户优先级”

高优先级的客户必须优先服务（这里假设通过调整目标函数惩罚来实现，或者仅仅是作为标签算法的某种约束）。

* **思考路径：**
1. **数据源头变了吗？** 变了。txt 文件里多了一列，或者逻辑上多了一个属性。
2. **谁持有数据？** `instance` 和 `models`。


* **修改影响范围：**
* `models.py`: 修改 `Customer` 类，增加 `priority: int` 字段。
* `instance.py`: 修改 `_read_solomon` 函数，解析文本时把这一列读进去。
* `pricing.py`: 如果你的逻辑是“高优先级不能等待”，那就要修改 `extend` 逻辑。
* `master.py`: 如果你的逻辑是“没服务高优先级客户要罚款”，那就要修改 Master 的约束或目标函数。


* **结论：** **数据结构的改变通常是“穿透性”的**，会自底向上影响多个模块。

#### 场景三：我想换一个求解器，不用 Gurobi 了，用开源的 SCIP

Gurobi 版权到期了，要换免费的。

* **思考路径：**
1. **谁在用 Gurobi？** 只有主问题。
2. **子问题在用吗？** 没有，子问题只用原生 Python。
3. **控制器在用吗？** 控制器只调用 `.solve()` 方法。


* **修改影响范围：**
* `master.py`: **重写整个文件**。把 `import gurobipy` 换成 `import pyscipopt`，重写 `add_route` 和 `solve` 的内部实现。
* **关键点**：只要你保证 `master.py` 的对外接口（`solve()` 返回 obj 和 duals，`add_route()` 接收 route）保持不变，**其他所有文件一行代码都不用改**。
* 这就是**封装（Encapsulation）**的威力。



---

### 第三部分：如何验证你的理解？（练习）

为了验证你是否掌握了这种分离逻辑，请尝试回答这个问题：

**假设我要把目标函数从“最小化总距离”改为“最小化车辆数，其次最小化总距离”。**

请思考：

1. **`instance.py`** 要动吗？
2. **`pricing.py`** 要动吗？（提示：Reduced Cost 的公式  里的  代表什么？）
3. **`master.py`** 要动吗？（提示：Gurobi 的 Obj 谁定的？）

---

*(你可以先想一下，然后看下面的答案)*

<details>
<summary>点击查看参考答案</summary>

1. **`instance.py`**: 不需要动。距离数据还是那些。
2. **`master.py`**: **核心改动点**。
* 你需要给每辆车（每个变量）增加一个巨大的固定成本（Fixed Cost），比如 10000。
* 这样 Gurobi 为了省成本，就会拼命减少车辆使用。
* 修改 `add_route`，在计算 `obj` 时，加上 `fixed_cost`。


3. **`pricing.py`**: **需要微调**。
* 因为 Reduced Cost 的公式变成了 。
* 现在的  包含了固定成本。
* 你需要确保 `Label` 计算 cost 时，出发的第一步（离开 Depot）要加上这个固定成本，或者在 Master 传回 Duals 时处理。
* *通常做法：* 其实 `pricing.py` 不需要改代码逻辑，只需要 Master 在计算 Duals 时把车辆数的约束对偶值  考虑进去即可。



</details>

这种**“动哪里，不动哪里”**的判断力，就是架构师思维。这一套文件结构，就是为了让你在修改逻辑时，能精准定位，而不是在一团乱麻中担惊受怕。

