这份报告旨在帮你梳理刚刚完成的代码重构工作。

从单文件脚本（Script）转向模块化工程（Project）是程序员进阶的重要一步。虽然文件变多了，看起来变复杂了，但这是为了驾驭更复杂问题的必经之路。

---

# 项目架构与文件职责说明报告

## 1. 文件职责清单 (The "What")

现在的项目像是一个精密的**工厂**，每个文件就是一个**专门的车间**，只负责一件特定的事情。

### 📁 根目录

* **`main.py` (启动器)**
* **职责**：这是整个程序的入口（Ignition Key）。
* **做什么**：它不包含任何算法逻辑。它只负责配置参数（如文件路径 `C101.txt`）、初始化数据对象、启动求解器，并打印最终结果。
* **比喻**：它是汽车的**点火开关**和**仪表盘**。



### 📁 src/ (源代码核心包)

* **`__init__.py` (胶水)**
* **职责**：告诉 Python “`src` 是一个可导入的包”。
* **做什么**：通常是空的，或者用来暴露对外的接口。没有它，你无法跨文件夹 `import`。


* **`models.py` (数据原子)**
* **职责**：定义数据的**形状**。
* **做什么**：这里只有 `Customer` 类定义。它不包含任何 `for` 循环或逻辑，只规定一个客户必须有 `id`, `x`, `y` 等属性。
* **比喻**：这是**设计图纸**或**模具**。它规定了砖头长什么样，但它不负责砌墙。


* **`instance.py` (数据中心)**
* **职责**：负责脏活累活（读文件、算距离）并提供**只读数据**。
* **做什么**：它把文本文件解析成内存里的对象。一旦加载完成，它就是上帝视角的“地图”。
* **比喻**：这是**档案室**或**数据库**。所有算法都要来这里查阅距离和需求，但没人能修改这里的数据。


* **`pricing.py` (物理引擎 / 子问题)**
* **职责**：负责寻找一条“负 Reduced Cost”的路径。
* **做什么**：包含了 `Label` 类、资源扩展函数 (`extend`)、支配规则 (`is_dominated`) 和标签搜索算法。这是计算最密集的地方。
* **比喻**：这是**探路者**或**研发部门**。主问题说“我要这种类型的路径”，探路者就去地图上跑，找出一口符合要求的路径回来。


* **`master.py` (决策大脑 / 主问题)**
* **职责**：负责与 Gurobi 交互，维护线性规划模型。
* **做什么**：初始化约束、添加列（变量）、获取对偶值（Duals）。它看不懂地图，它只看数学公式。
* **比喻**：这是**总经理**。他不管具体车怎么开（那是 pricing 的事），他只管统筹安排，看报表（Objective Value），并发放奖金（Dual values）来指导下一步方向。


* **`solver.py` (指挥官)**
* **职责**：协调 Master 和 Pricing 的循环交互。
* **做什么**：它写着 `while True` 循环。它拿 Master 的对偶值给 Pricing，拿 Pricing 的新路径给 Master，并判断何时停止。
* **比喻**：这是**项目经理**。他负责在这个闭环中传递信息，确保总经理和研发部门配合工作。



---

## 2. 为什么要分这么多文件？ (The "Why")

你可能会问：“我就写在一个 `vrptw.py` 里，一共 300 行，跑得也好好的，为什么要拆成 6 个文件？”

这涉及软件工程的核心原则：**关注点分离 (Separation of Concerns)**。

### 理由一：认知负荷 (Cognitive Load)

* **单文件时**：当你修改标签算法时，你的眼睛需要在 Gurobi 的约束代码和文件读取代码之间来回滚动。你的大脑需要同时处理“读取文件”、“线性规划”和“动态规划”三个复杂的概念。
* **拆分后**：当你打开 `pricing.py` 时，你的世界里只有图论和标签。你完全不需要关心文件是怎么读的，也不需要关心 Gurobi 是怎么解 LP 的。**你一次只处理一个难点。**

### 理由二：可复用性与可替换性 (Modularity)

* **场景**：假设明天你想把 Gurobi 换成开源的 SCIP 或 CPLEX。
* **单文件时**：你需要在一堆代码里小心翼翼地把 Gurobi 相关的行挑出来删掉，很容易误删标签算法的逻辑。
* **拆分后**：你只需要重写 `master.py`。`pricing.py` 和 `instance.py` 一个字都不用动。它们根本不在乎你用什么求解器。

### 理由三：调试与测试 (Debugging)

* **场景**：标签算法好像算错了，没找到最优路径。
* **单文件时**：你必须每次都运行整个程序，等待文件读取，等待 Gurobi 初始化，才能测到标签算法。
* **拆分后**：你可以新建一个 `test_pricing.py`，手动造几个点，直接调用 `PricingSolver` 进行单元测试，秒级反馈。

### 理由四：未来扩展 (Scalability)

这是最重要的理由。你现在的目标是**Branch-and-Price (分支定价)**。

* 如果要加分支定界，你需要在**搜索树的每个节点**都运行列生成。
* 如果是单文件，代码逻辑会复杂到让你崩溃（递归里套着循环，循环里套着 Gurobi）。
* 拆分后，你只需要在 `solver.py` 上层再加一层 `branching.py`，调用现有的组件即可。

---

## 3. 总结

* **Single File (脚本)** = **瑞士军刀**。小巧、方便，适合解决一次性的小问题。
* **Modular Project (工程)** = **专业手术刀套装**。每一把刀都有特定的用途，虽然占地方，但在做复杂手术（解决大规模 VRPTW）时，它是必须的。

你现在已经搭建好了一个**工业级求解器的骨架**。在这个骨架上，你可以稳健地添加分支定界、割平面、启发式初始化等高级功能，而不会导致代码坍塌。